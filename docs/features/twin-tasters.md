# Система поиска "Близнецов вкуса" (Twin Tasters)

## Обзор

Система поиска похожих пользователей (Twin Tasters) позволяет найти других киноманов с совпадающими вкусами на основе анализа карты вкуса (Taste Map).

## Архитектура

### 1. **API Эндпоинт** (`/api/user/similar-users`)

**Метод:** GET

**Параметры:**
- `limit`: количество похожих пользователей (default: 10, max: 50)
- `useCache`: использовать кэшированные результаты (default: true)

**Ответ:**
```json
{
  "similarUsers": [
    {
      "userId": "user123",
      "overallMatch": 85.5,
      "watchCount": 150,
      "memberSince": "2023-01-15T10:30:00Z"
    }
  ],
  "cached": true,
  "computedAt": "2026-02-24T10:30:00Z",
  "message": "Found 5 similar user(s)"
}
```

### 2. **Алгоритм сравнения** (`src/lib/taste-map/similarity.ts`)

Система вычисляет три метрики сходства:

#### a) **Taste Similarity** (50% вес)
- **Метод:** Cosine similarity жанров
- **Что сравнивает:** Векторы предпочтений жанров обоих пользователей
- **Формула:** A · B / (||A|| × ||B||)
- **Порог:** > 0.7 для признания пользователей похожими

#### b) **Rating Correlation** (30% вес)
- **Метод:** Pearson correlation coefficient
- **Что сравнивает:** Оценки общих просмотренных фильмов
- **Диапазон:** -1 (противоположные вкусы) до 1 (идентичные вкусы)
- **Нормализация:** (-1..1) → (0..1) для взвешивания

#### c) **Person Overlap** (20% вес)
- **Метод:** Jaccard similarity
- **Что сравнивает:** Пересечение любимых актеров и режиссеров
- **Формула:** |A ∩ B| / |A ∪ B|
- **Среднее:** (actors_overlap + directors_overlap) / 2

#### **Overall Match Score**
```
overallMatch = 
  tasteSimilarity × 0.5 + 
  normalizedRatingCorrelation × 0.3 + 
  personOverlap × 0.2
```

### 3. **Кэширование** (Redis, TTL: 24h)

Похожие пользователи кэшируются в Redis с ключом:
```
similar-users:{userId}
similarity:{userId}:{otherUserId}
```

**Жизненный цикл:**
1. Первый запрос → вычисляется полный список
2. Результаты → сохраняются в Redis на 24 часа
3. Последующие запросы → возвращаются кэшированные результаты
4. После 24h → кэш истекает, вычисляется заново

### 4. **Процесс поиска**

```
GET /api/user/similar-users
    ↓
1. Проверка прав (authentication)
2. Проверка минимальной истории пользователя (≥ 5 фильмов)
3. Попытка получить кэшированный список из Redis
    ├─ ЕСЛИ найди → вернуть результаты
    └─ ЕСЛИ не найди:
       ├─ Загрузить 100 активных пользователей (последние 30 дней)
       ├─ Для каждого кандидата:
       │  ├─ Получить TasteMap из Redis
       │  ├─ Вычислить коcинус-сходство жанров
       │  ├─ Вычислить корреляцию общих оценок
       │  ├─ Вычислить пересечение актеров/режиссеров
       │  └─ Если overallMatch > 0.7 → добавить в результаты
       ├─ Отсортировать по score (убывающий)
       └─ Сохранить в Redis

4. Обогащение данных (fetch userInfo)
5. Возвращение результатов
```

## UI Компонент: `TwinTasters`

**Локация:** `src/app/profile/taste-map/TwinTasters.tsx`

**Функциональность:**
- Загрузка похожих пользователей при монтировании компонента
- Отображение аватара, сроков присоединения, количества фильмов
- Визуализация процента сходства вкуса
- Советы по использованию

**Состояния:**
- Loading (spinner)
- Error (сообщение об ошибке)
- Empty (нет похожих пользователей)
- Loaded (список похожих пользователей)

## Интеграция в страницу `/profile/taste-map`

На странице `/profile/taste-map/page.tsx`:

```tsx
import TasteMapClient from './TasteMapClient';

export default async function TasteMapPage() {
  // ... gets tasteMap
  return (
    <TasteMapClient tasteMap={tasteMap} userId={session.user.id} />
  );
}
```

Компонент `TasteMapClient` теперь включает `<TwinTasters userId={userId} />` в конц и получает похожих пользователей.

## Производительность

### Оптимизация
1. **Sample-based search:** Проверка только 100 последних активных пользователей (не все)
2. **Redis caching:** Кэш на 24 часа для повторных запросов
3. **Minimum history check:** Пропуск пользователей с < 5 фильмами
4. **Parallel loading:** getTasteMap запускается параллельно для двух пользователей

### Сложность
- **Первый запрос:** O(n) где n=100 (активные пользователи)
- **Повторные запросы:** O(1) из Redis

## Примеры использования

### Для фронтенда
```tsx
// Получить похожих пользователей
const response = await fetch('/api/user/similar-users?limit=15');
const data = await response.json();

// data.similarUsers содержит массив пользователей с процентом сходства
data.similarUsers.forEach(twin => {
  console.log(`${twin.userId}: ${twin.overallMatch}% match`);
});
```

### Для админа (анализ)
```bash
# Проверить кэшированное значение в Redis
redis-cli get "similar-users:user123"
# Результат: JSON список похожих пользователей если кэш есть
```

## Возможные усовершенствования

1. **Расширенное кэширование**
   - Параллельный расчет для batches пользователей
   - Incrementally update кэш вместо полного пересчета

2. **Улучшенный алгоритм**
   - Добавить контент type similarity (только фильмы vs фильмы)
   - Добавить temporal similarity (активны ли в одно время суток)
   - Использовать collaborative filtering

3. **Персонализация**
   - Позволить пользователю выбирать критерии (жанры, актеры, режиссеры)
   - Показывать "противоположные вкусы" (антиблизнецы)

4. **Социальные функции**
   - Позволить "подписаться" на близнеца для рекомендаций
   - Совместное просмотрение рекомендаций

## Отладка

### Логи
Система логирует:
- Начало вычисления похожести: количество кандидатов
- Ошибки при вычислении: userId и reason
- Результаты: количество найденных похожих пользователей

### Проверка кэша
```bash
# В Redis CLI
keys "similar-users:*"
get "similar-users:cmkbc7sn2000104k3xd3zyf2a"
```

### Тестирование
```bash
# Запрос к API
curl "http://localhost:3000/api/user/similar-users?limit=5&useCache=false"
```
